#! /usr/bin/env bqn

# TODO the byte order might be reversed sometimes,
# and i haven't tested with a machine that has reverse byte order,
# so errors might come about because of that.

HexToDecâ†{16âŠ¸Ã—âŠ¸+ËœÂ´âŒ½(âˆ¾"0A"+âŸœâ†•Â¨10â€¿6)âŠğ•©}

# Types of sockets
socket_type â‡ {
  sock_stream    â‡ 1   # Sequenced, reliable, connection-based byte streams
  sock_dgram     â‡ 2   # Connectionless, unreliable datagrams of fixed maximum length.
  sock_raw       â‡ 3   # Raw protocol interface.
  sock_rdm       â‡ 4   # Reliably-delivered messages.
  sock_seqpacket â‡ 5   # Sequenced, reliable, connection-based, datagrams of fixed maximum length.
  sock_dccp      â‡ 6   # Datagram Congestion Control Protocol.
  sock_packet    â‡ 10  # Linux specific way of getting packets at the dev level. For writing rarp and other similar things on the user level.

  # Flags to be ORed into the type parameter of socket and socketpair and used for the flags parameter of paccept.
  sock_cloexec  â‡ 2000000  # Atomically set close-on-exec flag for the new descriptor(s).
  sock_nonblock â‡ 4000  # Atomically mark descriptor(s) as non-blocking.
}
pf_inet â‡ 2 # IP protocol family.
af_inet â‡ pf_inet

errno â† {
  eperm           â‡ 1 # Operation not permitted
  enoent          â‡ 2 # No such file or directory
  esrch           â‡ 3 # No such process
  eintr           â‡ 4 # Interrupted system call
  eio             â‡ 5 # Input/output error
  enxio           â‡ 6 # No such device or address
  e2big           â‡ 7 # Argument list too long
  enoexec         â‡ 8 # Exec format error
  ebadf           â‡ 9 # Bad file descriptor
  echild          â‡ 10 # No child processes
  eagain          â‡ 11 # Resource temporarily unavailable
  ewouldblock     â‡ eagain # Same as EAgain in the c-gnu standard, seems the two are different sometimes, need to figure out when.
  enomem          â‡ 12 # Cannot allocate memory
  eacces          â‡ 13 # Permission denied
  efault          â‡ 14 # Bad address
  enotblk         â‡ 15 # Block device required
  ebusy           â‡ 16 # Device or resource busy
  eexist          â‡ 17 # File exists
  exdev           â‡ 18 # Invalid cross-device link
  enodev          â‡ 19 # No such device
  enotdir         â‡ 20 # Not a directory
  eisdir          â‡ 21 # Is a directory
  einval          â‡ 22 # Invalid argument
  enfile          â‡ 23 # Too many open files in system
  emfile          â‡ 24 # Too many open files
  enotty          â‡ 25 # Inappropriate ioctl for device
  etxtbsy         â‡ 26 # Text file busy
  efbig           â‡ 27 # File too large
  enospc          â‡ 28 # No space left on device
  espipe          â‡ 29 # Illegal seek
  erofs           â‡ 30 # Read-only file system
  emlink          â‡ 31 # Too many links
  epipe           â‡ 32 # Broken pipe
  edom            â‡ 33 # Numerical argument out of domain
  erange          â‡ 34 # Numerical result out of range
  edeadlk         â‡ 35 # Resource deadlock avoided
  enametoolong    â‡ 36 # File name too long
  enolck          â‡ 37 # No locks available
  enosys          â‡ 38 # Function not implemented
  enotempty       â‡ 39 # Directory not empty
  eloop           â‡ 40 # Too many levels of symbolic links
  enomsg          â‡ 42 # No message of desired type
  eidrm           â‡ 43 # Identifier removed
  echrng          â‡ 44 # Channel number out of range
  el2nsync        â‡ 45 # Level 2 not synchronized
  el3hlt          â‡ 46 # Level 3 halted
  el3rst          â‡ 47 # Level 3 reset
  elnrng          â‡ 48 # Link number out of range
  eunatch         â‡ 49 # Protocol driver not attached
  enocsi          â‡ 50 # No CSI structure available
  el2hlt          â‡ 51 # Level 2 halted
  ebade           â‡ 52 # Invalid exchange
  ebadr           â‡ 53 # Invalid request descriptor
  exfull          â‡ 54 # Exchange full
  enoano          â‡ 55 # No anode
  ebadrqc         â‡ 56 # Invalid request code
  ebadslt         â‡ 57 # Invalid slot
  ebfont          â‡ 59 # Bad font file format
  enostr          â‡ 60 # Device not a stream
  enodata         â‡ 61 # No data available
  etime           â‡ 62 # Timer expired
  enosr           â‡ 63 # Out of streams resources
  enonet          â‡ 64 # Machine is not on the network
  enopkg          â‡ 65 # Package not installed
  eremote         â‡ 66 # Object is remote
  enolink         â‡ 67 # Link has been severed
  eadv            â‡ 68 # Advertise error
  esrmnt          â‡ 69 # Srmount error
  ecomm           â‡ 70 # Communication error on send
  eproto          â‡ 71 # Protocol error
  emultihop       â‡ 72 # Multihop attempted
  edotdot         â‡ 73 # RFS specific error
  ebadmsg         â‡ 74 # Bad message
  eoverflow       â‡ 75 # Value too large for defined data type
  enotuniq        â‡ 76 # Name not unique on network
  ebadfd          â‡ 77 # File descriptor in bad state
  eremchg         â‡ 78 # Remote address changed
  elibacc         â‡ 79 # Can not access a needed shared library
  elibbad         â‡ 80 # Accessing a corrupted shared library
  elibscn         â‡ 81 # .lib section in a.out corrupted
  elibmax         â‡ 82 # Attempting to link in too many shared libraries
  elibexec        â‡ 83 # Cannot exec a shared library directly
  eilseq          â‡ 84 # Invalid or incomplete multibyte or wide character
  erestart        â‡ 85 # Interrupted system call should be restarted
  estrpipe        â‡ 86 # Streams pipe error
  eusers          â‡ 87 # Too many users
  enotsock        â‡ 88 # Socket operation on non-socket
  edestaddrreq    â‡ 89 # Destination address required
  emsgsize        â‡ 90 # Message too long
  eprototype      â‡ 91 # Protocol wrong type for socket
  enoprotoopt     â‡ 92 # Protocol not available
  eprotonosupport â‡ 93 # Protocol not supported
  esocktnosupport â‡ 94 # Socket type not supported
  eopnotsupp      â‡ 95 # Operation not supported
  epfnosupport    â‡ 96 # Protocol family not supported
  eafnosupport    â‡ 97 # Address family not supported by protocol
  eaddrinuse      â‡ 98 # Address already in use
  eaddrnotavail   â‡ 99 # Cannot assign requested address
  enetdown        â‡ 100 # Network is down
  enetunreach     â‡ 101 # Network is unreachable
  enetreset       â‡ 102 # Network dropped connection on reset
  econnaborted    â‡ 103 # Software caused connection abort
  econnreset      â‡ 104 # Connection reset by peer
  enobufs         â‡ 105 # No buffer space available
  eisconn         â‡ 106 # Transport endpoint is already connected
  enotconn        â‡ 107 # Transport endpoint is not connected
  eshutdown       â‡ 108 # Cannot send after transport endpoint shutdown
  etoomanyrefs    â‡ 109 # Too many references: cannot splice
  etimedout       â‡ 110 # Connection timed out
  econnrefused    â‡ 111 # Connection refused
  ehostdown       â‡ 112 # Host is down
  ehostunreach    â‡ 113 # No route to host
  ealready        â‡ 114 # Operation already in progress
  einprogress     â‡ 115 # Operation now in progress
  estale          â‡ 116 # Stale file handle
  euclean         â‡ 117 # Structure needs cleaning
  enotnam         â‡ 118 # Not a XENIX named type file
  enavail         â‡ 119 # No XENIX semaphores available
  eisnam          â‡ 120 # Is a named type file
  eremoteio       â‡ 121 # Remote I/O error
  edquot          â‡ 122 # Disk quota exceeded
  enomedium       â‡ 123 # No medium found
  emediumtype     â‡ 124 # Wrong medium type
  ecanceled       â‡ 125 # Operation canceled
  enokey          â‡ 126 # Required key not available
  ekeyexpired     â‡ 127 # Key has expired
  ekeyrevoked     â‡ 128 # Key has been revoked
  ekeyrejected    â‡ 129 # Key was rejected by service
  eownerdead      â‡ 130 # Owner died
  enotrecoverable â‡ 131 # State not recoverable
  erfkill         â‡ 132 # Operation not possible due to RF-kill
  ehwpoison       â‡ 133 # Memory page has hardware error
}

flags â† {
  msg_Oob          â‡ HexToDec "1"
  msg_Peek         â‡ HexToDec "2"
  msg_Dontroute    â‡ HexToDec "4"
  msg_Ctrunc       â‡ HexToDec "8"
  msg_Proxy        â‡ HexToDec "10"
  msg_Trunc        â‡ HexToDec "20"
  msg_Dontwait     â‡ HexToDec "40"
  msg_Eor          â‡ HexToDec "80"
  msg_Waitall      â‡ HexToDec "100"
  msg_Fin          â‡ HexToDec "200"
  msg_Syn          â‡ HexToDec "400"
  msg_Confirm      â‡ HexToDec "800"
  msg_Rst          â‡ HexToDec "1000"
  msg_Errqueue     â‡ HexToDec "2000"
  msg_Nosignal     â‡ HexToDec "4000"
  msg_More         â‡ HexToDec "8000"
  msg_Waitforone   â‡ HexToDec "10000"
  msg_Batch        â‡ HexToDec "40000"
  msg_Zerocopy     â‡ HexToDec "4000000"
  msg_Fastopen     â‡ HexToDec "20000000"
  msg_Cmsg_cloexec â‡ HexToDec "40000000"
}

sockaddress â‡ "{u16,[14]u8}"
# unsigned short int # sa_family
# char [14]; # sa_data


sockaddress_in â‡ "{u16,u16,{u32},[8]u8}"

address_len â‡ 16
addressType â‡ {
  sin_family  â‡ 0 # u16
  sin_port    â‡ 1 # u16
  sin_address â‡ 2 # {u32}
  sin_zero    â‡ 3 # u8[8]
}

sockaddress_storage â‡ "{u16,[118]u8,u64}"
#  {
#    ss_family    # u16
#    __ss_padding # u8[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))]
#    __ss_align   # u64
#  }


ni_maxhostâ€¿ni_maxserv â‡ 1025â€¿32

# sizeof(address) â† 16

socketPath â‡ "/usr/lib/x86_64-linux-gnu/libsocket++.so.1"
lf â† 10+@

pollIn â† 1

pollfd â‡ "{i32,i16,i16}"
# int   # fd         # file descriptor
# short # events     # requested events
# short # revents    # returned events

fcntl       â‡ socketPath â€¢FFI "i32"â€¿"fcntl"â€¿"i32"â€¿"i32"â€¿"i32"
pollC       â‡ socketPath â€¢FFI "i32"â€¿"poll"â€¿("&"âˆ¾pollfd)â€¿"i32"â€¿"i32" # fds nfds(len of fds) timeout
socket      â‡ socketPath â€¢FFI "i32"â€¿"socket"â€¿"i32"â€¿"i32"â€¿"i32"
htons       â‡ socketPath â€¢FFI "u16"â€¿"htons"â€¿">u16"
send        â‡ socketPath â€¢FFI "i64"â€¿"send"â€¿"i32"â€¿"*u8"â€¿"u64"â€¿"i32"
connect     â‡ socketPath â€¢FFI "i32"â€¿"connect"â€¿"i32"â€¿"*{u16,u16,{u32},[8]u8}"â€¿"u32"
close       â‡ socketPath â€¢FFI "i32"â€¿"close"â€¿">i32"
recvC       â‡ socketPath â€¢FFI "i64"â€¿"recv"â€¿"i32"â€¿"&u8"â€¿"u64"â€¿"i32"
accept      â‡ socketPath â€¢FFI "i32"â€¿"accept"â€¿"i32"â€¿('&'âˆ¾sockaddress)â€¿"&u32"
bind        â‡ socketPath â€¢FFI "i32"â€¿"bind"â€¿"i32"â€¿('&'âˆ¾sockaddress_in)â€¿"u32"
getsockname â‡ socketPath â€¢FFI "i32"â€¿"getsockname"â€¿"i32"â€¿('&'âˆ¾sockaddress_in)â€¿"&u32"
ntohs       â‡ socketPath â€¢FFI "u16"â€¿"ntohs"â€¿">u16"
listen      â‡ socketPath â€¢FFI "i32"â€¿"listen"â€¿"i32"â€¿"i32"

o_nonblock â† 2048
f_setfl â† 4

Recv â† {ğ•Šsockfdâ€¿bufferâ€¿bufferLengthâ€¿flags:
  lenâ€¿updatedBuffer â† RecvCâŸ¨sockfd, buffer, bufferLength, flagsâŸ©
  {
    Â¯1â‰ Ã—len?
    # sometimes returns âŸ¨@âŸ© when using recv multiple times, not sure why
    @+lenâ†‘updatedBuffer
  ;
    # Handle error
    err â† {(ğ•âŸ¨âŸ©).Read 0}@â€¢FFI"*i32"â€¿"__errno_location"
    Pâ†1â†“âŸœâˆ¾lfâŠ¸âˆ¾Â¨
    âŸ¨
      "No messages are available at the socket"
      # "The socket is marked nonblocking and the receive operation"
      # "would block, or a receive timeout had been set and the"
      # "timeout expired before data was received.  POSIX.1 allows"
      # "either error to be returned for this case, and does not"
      # "require these constants to have the same value, so a"
      # "portable application should check for both possibilities."
    âŸ©PâŠ¸!(errâ‰¢errno.eagain) âˆ§ errâ‰¢errno.ewouldblock

    âŸ¨
      "The argument sockfd is an invalid file descriptor."
    âŸ©PâŠ¸!errâ‰¢errno.ebadf

    âŸ¨
      "A remote host refused to allow the network connection"
      "(typically because it is not running the requested"
      "service)."
    âŸ©PâŠ¸!errâ‰¢errno.econnrefused

    âŸ¨
      "The receive buffer pointer(s) point outside the process's"
      "address space."
    âŸ©PâŠ¸!errâ‰¢errno.efault

    âŸ¨
      "The receive was interrupted by delivery of a signal before"
      "any data was available; see signal(7)."
    âŸ©PâŠ¸!errâ‰¢errno.eintr

    âŸ¨
      "Invalid argument passed."
    âŸ©PâŠ¸!errâ‰¢errno.einval

    âŸ¨
      "Could not allocate memory for recvmsg()."
    âŸ©PâŠ¸!errâ‰¢errno.enomem

    âŸ¨
      "The socket is associated with a connection-oriented"
      "protocol and has not been connected (see connect(2) and"
      "accept(2))."
    âŸ©PâŠ¸!errâ‰¢errno.enotconn

    âŸ¨
      "The file descriptor sockfd does not refer to a socket."
    âŸ©PâŠ¸!errâ‰¢errno.enotsock

    !"Unknown error code "âˆ¾â€¢Repr err
  }
}

# work in progress plans on proper polling
# somethingâ€¿lenOfFds â† Poll lenOfFdsâ€¿
# TODO experiment and find what's the best return value of Poll, maybe revents (meaning return-events)
Poll â† {ğ•Šfd:
  lenâ€¿âŸ¨fdNewâ€¿eventsâ€¿reventsâŸ© â† PollC âŸ¨â‹ˆfdâ€¿1â€¿0â‹„pollInâ‹„0âŸ© #  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  #â€¢Show lenâ€¿fdNewâ€¿eventsâ€¿revents
  { 0: @ # timeout
  ;Â¯1: !"Error"
  ; 1: len
  }Ã—len
}
# something has the representation:
# int   # fd         # file descriptor
# short # events     # requested events
# short # revents    # returned events


CreateServer â‡ {ğ•Š:
  # create socket
  fd â† SocketâŸ¨pf_inet, socket_type.sock_stream, 0âŸ©

  # bind to open port
  address â† âŸ¨af_inet,0,âŸ¨0âŸ©,8â¥Š0âŸ©

  address â†© {
    1â€¿Â·: !"bind error:"
  ; 0â€¿âŸ¨aâŸ©: a
  } BindâŸ¨fd, â‹ˆaddress, address_lenâŸ©

  # read port
  address â†© {
    âŸ¨err, âŸ¨addressNewâŸ©, âŸ¨lenNewâŸ©âŸ© â† GetsocknameâŸ¨fd, â‹ˆaddress, â‹ˆaddress_lenâŸ©
    !lenNewâ‰¡address_len
    "Couldn't get socket name"!Â¬err
    addressNew
  }

  portâ‡âŒŠ Ntohs 1âŠ‘address

  "listen error:"!Â¬Listen fdâ€¿1
  Fcntl âŸ¨fd, f_setfl, o_nonblockâŸ©

  SocketClose â† Close

  SearchForConnection â‡ Pollâˆ˜fd

  # accept incoming connection
  AcceptConnection â‡ {ğ•Š@:
    caddress_len â† 16

    # Todo, poll before accepting. I think that would be more inline with the standard.
    cfdâ€¿âŸ¨âŸ¨nâ‹„addressâŸ©âŸ©â€¿âŸ¨Â·âŸ© â† AcceptâŸ¨fd, â‹ˆâŸ¨0, 14â¥Š0âŸ©, â‹ˆcaddress_lenâŸ©

    # I have no idea what the two first elements are, and rest is the ipv4 address
    address(4â†‘â†“Ëœ)â†©2

    "Connection not found"!Â¯1â‰¢cfd
    "Only address IPV4 allowed"!2â‰¡n
    connection â† cfd

    SearchForMessage â‡ Pollâˆ˜connection

    _WithMessage_ â‡ {@âŠ¸â‰¡â—¶âŸ¨({ğ•©.Close@}âŠ¢ğ”½)Listenâˆ˜@â‹„ğ”¾âŸ©SearchForMessage}

    Listen â‡ {ğ•ŠlengthOfReadMessage:
      # read from client with recv!
      l â† 1024âŸ(@âŠ¸â‰¡)ğ•©
      RecvâŸ¨connection, lâ¥Š0, l, flags.msg_dontwaitâŸ©
    }
    Close â‡ SocketCloseâˆ˜connection
    addressâ‡
  }
  _WithConnection_ â‡ {@âŠ¸â‰¡â—¶âŸ¨({ğ•©.Close@}âŠ¢ğ”½)AcceptConnectionâˆ˜@â‹„ğ”¾âŸ©SearchForConnection}

  Close â‡ SocketCloseâˆ˜fd
}


CreateClient â‡ {ipv4_addressğ•Šport:
  fd â† SocketâŸ¨pf_inet, socket_type.sock_stream, 0âŸ©

  # connect to machine at specified port
  address â† âŸ¨
    af_inet
    Htons port # Htons sets byte order to follow network protocal standards
    â‹ˆ 256âŠ¸Ã—âŠ¸+ËœÂ´ipv4_address
    8â¥Š0
  âŸ©

  # connect to server
  "connect error:"!Â¬ConnectâŸ¨fd, â‹ˆaddress, address_lenâŸ©

  SendRenamed â† Send
  Send â‡ {SendRenamedâŸ¨fd, ğ•©-@, â‰ ğ•©, 0 âŸ©}
  Close â‡ Closeâˆ˜fd
}

_asServer â‡ {({ğ•©.Close}âŠ¢ğ”½)CreateServer}
_asClient â‡ {({ğ•©.Close}âŠ¢ğ”½)CreateClient}

#       AF_INET6
#              src points to a character string containing an IPv6
#              network address.  The address is converted to a struct
#              in6_addr and copied to dst, which must be sizeof(struct
#              in6_addr) (16) bytes (128 bits) long.  The allowed formats
#              for IPv6 addresses follow these rules:
#
#              â€¢  The preferred format is x:x:x:x:x:x:x:x.  This form
#                 consists of eight hexadecimal numbers, each of which
#                 expresses a 16-bit value (i.e., each x can be up to 4
#                 hex digits).
#
#              â€¢  A series of contiguous zero values in the preferred
#                 format can be abbreviated to ::.  Only one instance of
#                 :: can occur in an address.  For example, the loopback
#                 address 0:0:0:0:0:0:0:1 can be abbreviated as ::1.  The
#                 wildcard address, consisting of all zeros, can be
#                 written as ::.
#
#              â€¢  An alternate format is useful for expressing
#                 IPv4-mapped IPv6 addresses.  This form is written as
#                 x:x:x:x:x:x:d.d.d.d, where the six leading xs are
#                 hexadecimal values that define the six most-significant
#                 16-bit pieces of the address (i.e., 96 bits), and the
#                 ds express a value in dotted-decimal notation that
#                 defines the least significant 32 bits of the address.
#                 An example of such an address is
#                 ::FFFF:204.152.189.116.
#
#              See RFC 2373 for further details on the representation of
#              IPv6 addresses.
#
#